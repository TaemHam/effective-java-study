# 아이템 48. 스트림 병렬화는 주의해서 적용하라

### 자바 동시성 프로그래밍의 역사
* 릴리스
스레드, 동기화, wait/notify를 지원했다.

> **📌 참고**<br>
> wait : 갖고 있던 고유 락을 해제하고, 스레드를 잠들게 한다.<br>
> notify :잠들어 있던 스레드 중 임의로 하나를 골라 깨운다.

* 자바 5 이후
동시성 컬렉션인 java.util.concurrent 라이브러리와 Executor 프레임워크 지원했다.

* 자바 7 이후
고성능 병렬 분해 프레임워크인 포크-조인(fork-join) 패키지를 추가했다.

* 자바 8 이후
parallel 메서드만 한 번 호출하면 파이프라인을 병렬 실행할 수 있는 스트림을 지원했다.

이처럼 동시성 프로그램을 작성하기는 점점 쉬워지고 있지만, 동시성 프로그래밍을 할때는 항상 **안전성(safety)와 응답 가능(liveness) 상태를 유지 해야 하는 것에 주의**해야 한다.

### 동시성 프로그래밍 주의점

다음의 메르센 소수를 찾는 코드를 보자. (메르센 소수란, 어떤 수가 소수이면서 다른 정수 x에 대해 2**x - 1가 되는 수들의 집합이다.)

```JAVA
public class ParallelMersennePrimes {
    public static void main(String[] args) {
        primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE))
                .parallel() // 스트림 병렬화
                .filter(mersenne -> mersenne.isProbablePrime(50))
                .limit(20)
                .forEach(System.out::println);
    }

    static Stream<BigInteger> primes() {
        return Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }
}
```

무작정 성능을 향상시키기 위해 parallel() 를 사용하면, 스트림 라이브러리가 이 파이프라인을 병렬화하는 방법을 찾아내지 못할 때, 위와 같이 아무것도 출력하지 못하면서 CPU는 90% 나 잡아먹는 상태가 무한히 계속되는 문제가 발생할 수 있다.

### 병렬 수행 효율에 영향을 주는 요소들

1. 데이터 소스 

데이터 소스가 Stream.iterate인 경우, 반복을 돌릴 데이터가 미리 정해진 게 아닌, 이전 데이터에서 함수를 돌려 나온 값을 사용한다. 때문에 데이터를 원하는대로 나누기가 어려워 파이프라인으로 병렬화 하지 못한다.

반대로 데이터를 원하는 크기로 나누기 쉽고, 또 참조 지역성이 높은 자료구조(ex. ArrayList, HashMap, HashSet 등)라면 효율이 더욱 좋아진다. 

> **📌 참고** <br>
> 참조 지역성이란?<br>
> 특정 데이터가 참조되면, 그 주변의 다른 데이터도 같이 참조될 가능성이 높다는 성질이다.<br>
> * 시간 지역성 : 최근에 참조된 주소는 빠른 시간 내에 다시 참조되는 특성
> * 공간 지역성 : 참조된 주소와 인접한 주소의 내용이 다시 참조되는 특성
> * 순차 지역성 : 데이터가 순차적으로 엑세스 되는 특성(공간 지역성) 

만약 직접 구현한 Stream, Iterable, Collection이 병렬화의 이점을 제대로 누리게 하고 싶다면 `spliterator` 메서드를 반드시 재정의하고 결과 스트림의 병렬화 성능을 강도 높게 테스트해야 한다.

같은 이유로, 무작위 수들로 이뤄진 스트림을 병렬화하고 싶다면 `SplittableRandom`을 사용하는 게 좋다.

2. 중간 연산

만약 중간 연산으로 limit 을 사용한다면, limit이 달성되는 결과가 나오더라도 CPU의 코어가 남으면 이후의 값도 계산하다가 조건이 완료되면 값을 버린다. 

예를 들어, 10번째 소수를 찾는 스트림을 병렬화 한다고 해보자. 실제 10번째 결과값이 나오기 전까진 현재 계산중인 프로세스가 10번째 값을 도출하는지 모르기 때문에 남는 CPU 코어는 11번째, 12번째 소수를 계산하기 시작한다는 것이다.

3. 종단 연산

종단 연산 중 병렬화에 가장 적합한 것은 reduce() 메서드다. 그리고 anyMatch, allMatch, noneMatch처럼 조건에 맞으면 바로 반환되는 메서드도 병렬화에 적합하다. 

반면, 가변 축소를 수행하는 Stream의 collect() 메서드는 병렬화에 적합하지 않다.
가변 축소 메서드란, 결과값을 가공하여 새로운 컬렉션으로 추출하는 메서드를 말한다.

### 결론

병렬화가 꼭 성능 향상을 불러오는 것인 아니다. 병렬 처리가 효율적인 작업인 경우(ex. 빅데이터) 병렬화를 적용한 코드가 계산도 정확하고 성능도 좋아졌다면, 그제서야 운영 코드에 적용하는 것이 바람직하다.