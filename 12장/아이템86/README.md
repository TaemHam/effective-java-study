# 아이템 86. Serializable을 구현할지는 신중히 결정하라

## Serializable이란?

- 자바의 인스턴스를 직렬화할 수 있게 하려면 클래스를 선언할 때 implements Serializable만 덧붙이면 된다.

- 따라서 Serializable만 붙여주면 `외부의 자바 시스템`에서도 사용할 수 있도록 바이트 형태의 데이터로 변환을 할 수 있다.
  - 바이트 형태의 데이터를 자바 객체로 변환하는 역직렬화도 가능하다.

<br><br>

## Serializable을 사용했을 때의 단점

<br>

### Serializable을 구현하면 릴리스한 뒤에 수정이 어렵다.

- Serializable을 구현하면 직렬화된 바이트 스트림 인코딩 (직렬화 형태) 또한 하나의 공개 API가 된다.

- 그래서 이 클래스가 널리 퍼진다면, 그 직렬화 형태도 영원히 지원해야 한다.

- 만약 커스텀 직렬화 형태를 설계하지 않고 자바의 기본 방식을 사용하면 직렬화 형태는 내부 구현 방식에 영원히 종속된다.

  - 왜냐하면 커스텀 없이 기본 직렬화를 사용하면 클래스의 메타 정보도 직렬화에 반영된다. (직렬화 후의 바이트 데이터도 용량이 크다.)

  - 따라서 기존에 직렬화한 데이터를 다시 역직렬화할 때 클래스의 정보가 바뀌어있다면 예외가 발생할 수 있는 것이다. (호환 불가)

  - 그리고 private 필드나 메서드 또한 종속되기 때문에 캡슐화도 깨져버린다.

- 클래스와 직렬화 형태를 잘 설계하더라도 클래스를 유지보수하고 개선하는 데 제약이 될 가능성도 있다.

> **📌 직렬화가 클래스의 개선을 방해하는 예시**<br>
>
> - 직렬화를 하는데는 serialVersionID라는 고유 식별자가 필요하다.
> - 이는 static final long 필드이며, 명시하지 않으면 묵시적으로도 생성된다. (SHA-1 해시함수 사용)
> - 만약 묵시적으로 생성할 경우에는 클래스의 메타 정보까지 포함하여 값을 생성하는데, 클래스가 개선되는 경우 serialVersionID 값 또한 바뀌게 되므로 역직렬화 할 때 InvalidClassException 예외가 발생할 수 있다.

<br>

### Serializable을 구현하면 버그와 보안 구멍이 생길 위험이 높아진다.

- 객체는 생성자를 사용해 만드는 게 기본이다.

- 직렬화는 생성자가 없이도 객체를 만들 수 있는 방법을 제공하므로 언어의 기본 메커니즘을 우회하는 객체 생성 기법이다.

- 따라서 자바에서 제공하는 기본 역직렬화를 사용하면 불변식이 깨지고, 허가되지 않은 접근에 쉽게 노출될 수 있다.

<br>

### Serializable을 구현하면 해당 클래스의 신버전을 릴리스할 때 테스트할 것이 늘어난다.

- 직렬화 가능 클래스가 수정되면 구버전과의 호환성을 반드시 체크해야 한다.

- 이 문제점은 커스텀 직렬화를 잘 설계하여 다소의 테스트 부담을 줄일 수 있다.

<br><br>

## Serializable을 구현할 때 고려해야할 점

<br>

### Serializable의 구현 여부는 가볍게 결정할 사안이 아니다.

- 만약 자바 직렬화를 이용하는 프레임워크용으로 만든 클래스라면 직렬화를 사용해야 한다.

- 그러나 자바 직렬화를 사용하면 구현에 따른 비용도 적지 않으니 설계 시 이 점도 고려해야 한다.

  - 좋은 설계로 클래스를 만드는 비용

  - 예를 들어 직렬화 된 클래스를 배포 후 유지 보수 고려

  - 직렬화 된 데이터를 저장 시 용량이 큰 이슈 고려 등

- 대체로 값 클래스(BigInteger)는 Serializable을 구현하고, 동작 클래스 (Thread)는 Serializable을 구현하지 않았다.

<br>

### 상속용으로 설계된 클래스 및 인터페이스에는 대부분 Serializable을 구현하거나 확장하면 안된다.

- 만약 Serializable을 구현한 클래스만 지원하는 프레임워크를 사용하는 것이 아니라면, 하위 클래스에서도 직렬화에 대해 고려해야 하므로 비용이 클 수 있다.

- 상속용으로 설계 된 클래스 중 Serializable을 구현한 예로는 Throwable과 Component가 있다.

- Throwable은 RMI (Remote Method Invocation)을 통해 예외를 전송하기 위해 구현되었다. (현재는 많이 쓰이지 않음)
- Component는 GUI를 전송하고 저장, 복원하기 위해 구현했다. (현재는 많이 쓰이지 않음)

> **📌 RMI란?**<br>
>
> - RMI란 Remote Method Invocation로써 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술이다.

- 만약 클래스의 인스턴스 필드가 직렬화와 확장 모두 지원한다면 finalize 공격을 막기 위해 만드시 finalize를 재정의하고 final로 설계를 해야 한다.

- 그리고 인스턴스 필드의 초기화 값을 특정해야 한다면 readObjectNoData 메서드를 반드시 추가해야 한다.

<br>

### 내부 클래스는 직렬화를 구현하지 말자.

- 내부 클래스에 대한 기본 직렬화 형태가 분명하지 않기 때문에 직렬화를 구현하더라도 예상할 수 없는 결과를 만날 수 있다.

---

<br>

## 참고 사항

- [직렬화에 대한 참고 블로그 1](https://techblog.woowahan.com/2550/)
- [직렬화에 대한 참고 블로그 2](https://techblog.woowahan.com/2551/)

- [JPA 엔티티와 Serializable](https://www.baeldung.com/jpa-entities-serializable)
