# 아이템 89. 인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라

## 싱글턴 패턴을 사용 시 Serializable에 관련한 문제

- 싱글턴 패턴은 클래스 바깥에서 생성자를 호출하지 못하게 막는 방식으로 인스턴스가 오직 하나만 만들어짐을 보장한다.

- 그러나 Serializable을 구현하면 역직렬화를 통해 객체를 생성하는 방법을 제공하는 것이므로 더 이상 싱글턴이 아니게 된다.

  - 커스텀 직렬화를 사용하더라도 이 클래스가 초기화 될 때 만들어진 싱글턴을 위한 인스턴스 대신 별개의 인스턴스를 반환하게 된다.

- readResolve 메서드를 사용하면 readObject가 만들어낸 인스턴스를 다른 것으로 대체할 수 있다.

  - readResolve 메서드는 역직렬화 후 새로 생성된 객체를 인수로 호출된다.

  - 따라서 readResolve 메서드에서 싱글턴을 위한 인스턴스를 반환하면 새로 생성된 객체는 가비지 컬렉터의 대상이 된다.

  ```java
  public static final MyClass INSTANCE = new MyClass();

  private Object readResolve() {
    return INSTANCE;
  }
  ```

- readResolve 메서드에 INSTANCE를 반환하면 역직렬화를 통해 만들어진 인스턴스는 실 데이터를 가질 필요가 없다.

- 그러므로 모든 인스턴스 필드를 transient로 선언해야 한다.
  - readResolve를 인스턴스 통제 목적으로 사용한다면 객체 참조 타입 인스턴스 필드는 모두 transient로 선언해야 한다.
  - 왜냐하면 역직렬화된 객체의 참조를 공격할 여지가 남기 때문이다.

<br>

### 인스턴스 수를 통제할 클래스의 객체 참조 필드를 transient로 선언하지 않았을 때의 문제점

- 직렬화 된 바이트 스트림에서 싱글턴의 비 휘발성 (transient가 없는 필드)를 다른 필드로 교체해버린다.

- 따라서 readResolve에서 INSTANCE를 반환하더라도, 이미 공격받은 INSTANCE를 반환하게 되어버리는 것이다.

<br>

## 인스턴스 수를 통제할 때는 열거 타입을 사용하자.

- 객체 참조 타입에 transient를 선언하여 역직렬화 시의 공격을 막을 수는 있지만, 신경써야 할 사항들이 많다.

- 그러므로 원소 하나짜리 열거 타입으로 바꾸는 편이 더 낫다.

- 직렬화 가능한 인스턴스 통제 클래스를 열거 타입으로 구현하면, 선언한 상수 외의 다른 객체는 존재하지 않음을 자바가 보장해준다.

  - 임의의 네이티브 코드를 수행할 수 있는 특권을 가로챈 공격자를 막을 수는 없지만, transient를 선언하는 방식보다는 간단하다.

<br>

## readResolve를 사용해야 할 수 밖에 없는 경우

- 직렬화 가능 인스턴스 통제 클래스를 작성해야 하는데, 컴파일 타임에는 어떤 인스턴스들이 있는지 알 수 없는 상황이라면 열거 타입으로 표현할 수 없다.

- 그러므로 이 경우에는 readResolve를 사용해야 한다.

<br>

## readResolve의 접근성

- final 클래스에서는 readResolve를 private로 선언하자.

- final 클래스가 아니라면 다음 사항을 주의하자.

  - private로 선언하면 하위 클래스에서 사용할 수 없다.

  - protected나 public인 경우에 하위 클래스에서 재정의하지 않았다면 하위 클래스의 인스턴스를 역직렬화 한다면 ClassCastException을 일으킬 수 있다.
