# 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라.

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐이다. 이 특성을 일컬어 `정보 은닉`, 혹은 `캡슐화`라고 한다.

### 정보 은닉의 장점

* 시스템 개발 속도를 높인다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
* 시스템 관리 비용을 낮춘다. 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
* 정보 은닉 자체가 성능을 높여 주지는 않지만, 성능 최적화에 도움을 준다. 다른 컴포넌트에 영향을 주지 않고 최적화 할 수 있기 때문이다.
* 소프트웨어 재사용성을 높인다. 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때문이다.
* 큰 시스템을 제작하는 난이도를 낮춰준다.

### 정보 은닉을 위한 기본 원칙

**모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.** <br>
달리 말하면, 소프트웨어가 올바로 동작하는 한 항상 가장 낮은 접근 수준을 부여해야 한다는 것이다.

### 접근 수준

|제어자|같은 클래스|같은 패키지|하위 클래스|전체 클래스|
|---------------|:--------:|:-------:|:-------:|:-------:|
|private        |O         |X        |X        |X        |
|package-private|O         |O        |X        |X        |
|protected      |O         |O        |O        |X        |
|public         |O         |O        |O        |O        |

* 접근 수준 제어 순서

1. 공개할 API만 `public`으로
2. 나머지는 `private` 으로
3. 그 중 같은 패키지의 다른 클래스가 접근하는 것은 `package-private`으로

만약 3번이 많다면 컴포넌트를 더 분해해야 하는 건 아닌지 고민해보자.

* 접근 수준을 좁히지 못하게 하는 제약

바로 `재정의`다. 상위 클래스의 메서드를 재정의할 때는 그 접근 수준을 상위 클래스 에서 보다 좁게 설정할 수 없기 때문이다. 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 규칙(LSP)을 지키기 위해 필요하다.

* 접근 수준을 넓혀도 되는 경우

코드를 테스트하기 위해 접근 범위를 넓힐 수는 있다. 하지만 적당한 수준까지만 넓혀야 한다. 예를 들어, public 클래스의 private 멤버는 package-private 까지는 넓혀도 좋으나 그 이상은 안된다. 테스트 코드를 테스트 대상과 같이 놓고 접근할 수 있도록 해라.


<details>
<summary>애초에 private 메서드를 테스트 해야할까?</summary>

>private 메서드의 장점은 내부를 감추어 클라이언트와의 결합도를 낮춰주는데 있다.
>하지만 클라이언트인 테스트 클래스가 내부 메소드를 알고 있다면 코드에 대한 결합도가 높아진다.
>예를 들어, 반환값을 만드는 데 더 효율적인 방법을 찾아 내부 구현을 바꾸게 되면, 테스트는 바로 깨지게 된다.
>이렇게 테스트코드도 수정해야할 수 있으므로, 유지보수의 비용이 증가하게 된다.
>
>만약 private 메서드를 테스트하고 싶다면, 해당 메서드까지 도달하는 테스트 케이스를 만드는 것이 좋다.
</details>

### public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.

**그 필드에 담을 수 있는 값을 제한할 통제권이 없어지기 때문**이다. 이렇게 되면, 이 필드와 관련된 모든 것은 불변식을 보장할 수 없게 된다. 따라서 public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않게 된다. 

필드가 final이면서 불변 객체를 참조 하더라도 문제는 여전히 남는다. 내부 구현을 바꾸고 싶어도, 이 public 필드는 클래스 밖에서 참조할 가능성이 있어, 이 필드를 없애는 방식으로는 리팩터링 할 수 없게 되기 때문이다.

예외로, 해당 클래스가 표현하는 추상 개념을 완성하는 데 꼭 필요한 구성요소로써의 상수라면, public static final 필드로 공개해도 좋다. 이런 필드는 관례상 카멜케이스가 아닌, 대문자와 밑줄(_)을 이용해 표기한다.

하지만 아무리 그런 상황이라도, 가변 객체를 public static final 필드에 넣어 공개하거나 이를 그대로 반환하는 메서드를 제공하면 안된다. 예를 들어, public static final으로 둘 필드가 배열이라고 하자. 길이가 0이 아닌 배열은 모두 변경 가능하기 때문에, 이런 필드나 접근자를 제공한다면 클라이언트에서 그 배열의 내용을 수정할 수 있게 된다. 

일례로 다음 코드를 보자.

```JAVA
// 보안 허점이 숨어 있다. 
public static final Thing[] VALUES = { ... };
```

위 코드에는 '클라이언트가 배열 안의 내용물을 바꿀 수 있다'는 보안 허점이 존재한다.

해결책은 두 가지이다.

1. public 배열을 private으로 만들고 public 불변 리스트를 추가하는 방법

```JAVA
private static final Thing[] PRIVATE_VALUES = { ... };
public static final List<Thing> VALUES = 
    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

2. 배열을 private으로 만들고 그 복사본을 반환하는 public 메서드를 추가하는 방법 (방어적 복사)

```JAVA
private static final Thing[] PRIVATE_VALUES = { ... };
public static final Thing[] values() {
    return PRIVATE_VALUES.clone();
}
```

어느 반환타입이 더 쓰기 편할지, 성능은 어느 쪽이 나을지 고려해 선택하면 된다.

### 모듈 시스템으로 추가된 접근 수준

자바 9에 도입된 모듈을 사용하면 자신에 속하는 패키지 중 공개할 것들을 `module-info.java` 파일에 선언하고 모듈 밖에서 호출 할 수 있는 것들과, 그럴 수 없는 것들을 나눌 수 있다. 아무리 public 이라도, 모듈 내부에서만 호출 할 수 있도록 설정했다면 모듈 밖에선 사용할 수 없다.

이 접근 수준을 적극적으로 활용한 대표적인 예가 바로 `JDK` 이다. 자바 라이브러리에서 공개하지 않은 패키지들은 해당 모듈 밖에서는 절대 접근할 수 없다.

하지만 모듈의 장점을 제대로 누리려면 해야 할 일이 많다. 먼저 패키지들을 모듈 단위로 묶고, 모듈 선언에 패키지들의 모든 의존성을 명시해야한다. 그 다음 소스 트리를 재배치하고, 모듈 안으로부터 일반 패키지로의 모든 접근에 특별한 조치를 취해야 한다.

이 때문에 JDK 외에도 모듈 개념이 널리 받아들여질지 예측하기는 아직 이르다고 한다. **꼭 필요한 경우가 아니라면 당분간 사용하지 않는 것이 좋다.**