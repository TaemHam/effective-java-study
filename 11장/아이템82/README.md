# 아이템 82. 스레드 안전성 수준을 문서화하라

어떤 API는 API 자체에서 스레드 안정성을 보장하는 데 반해, 어떤 API는 아예 보장하지 않는 것이 있다.<br>
예) `ConcurrentHashMap` vs. `HashMap`

만약 이에 대해 API 문서에 적혀있지 않다면, 사용자는 API를 뜯어보거나 동시성 문제를 직접 겪어보지 않는 이상, <br>
사용하는 API에 대해 동기화를 얼마나 진행해야 스레드 안정적이게 되는지 알 수 없다.

이 상태로 동기화를 진행한다면, 사용자는 높은 확률로 동기화를 충분히 하지 못한 상태이거나, 지나치게 한 상태일 것이며, <br>
두 가지 모두 심각한 오류로 이어질 수 있다. [[아이템 78](https://github.com/TaemHam/effective-java-study/tree/main/11%EC%9E%A5/%EC%95%84%EC%9D%B4%ED%85%9C78)], [[아이템 79](https://github.com/TaemHam/effective-java-study/tree/main/11%EC%9E%A5/%EC%95%84%EC%9D%B4%ED%85%9C79)]

따라서, API를 작성할 때에는 **해당 API가 어느정도 수준의 스레드 안정성을 가지는지 꼭 문서화해야 한다**.

## 스레드 안정성 수준

스레드 안정성 수준은 크게 5가지로 나눌 수 있고, 안정성이 높은 순으로 다음과 같다:

1. 불변(Immutable) <br>
  - 인스턴스가 마치 상수와 같아서 외부 동기화가 필요 없는 경우 <br>
  - `String`, `Long`, `BigInteger`

2. 무조건적 스레드 안전 (Unconditionally thread-safe) <br>
  - 인스턴스는 수정될 수 있으나, 내부에서 충실히 동기화하여 **별도의 외부 동기화 없이 동시에 사용해도 안전한 경우** <br>
  - `AtomicLong`, `ConcurrentHashMap`

3. 조건부 스레드 안전 (Conditionally thread-safe) <br>
  - 무조건적 스레드 안전과 같으나, **일부 메서드는 동시에 사용하려면 외부 동기화가 필요한 경우** <br>
  - `Collections.synchronized`의 래퍼 메서드가 반환한 컬렉션들

4. 스레드 안전하지 않음 (Not thread-safe) <br>
  - 인스턴스는 수정될 수 있고, 내부에서 동기화가 진행되지 않아 <br>
  동시에 사용하려면 각각의 메서드 호출을 **외부 동기화 메커니즘으로 감싸야 하는 경우** <br>
  - `ArrayList`, `HashMap`

5. 스레드 적대적 (Thread-hostile) <br>

  - 모든 메서드 호출을 외부 동기화로 감싸더라도 멀티스레드 환경에서 안전하지 않은 경우 <br>
  - 정적 데이터를 아무 동기화 없이 수정하면 발생 <br>
  - 동시성을 고려하지 않고 실수로 만드는 경우이므로, <br>**문제를 고쳐 재배포하거나 `deprecated`로 지정해야 함**

### 조건부 스레드 안전 클래스

조건부 스레드 안전 클래스는, 그 이름처럼 어떤 특정한 조건 하에 스레드 안전이 보장이 되는 클래스다. <br>
따라서 어떤 순서로 호출할 때 외부 동기화가 필요한지, 어떤 락을 얻어야 하는지 등, <br>
**스레드 안전하기 위한 조건이 어떻게 되는지를 꼭 문서화 해야 한다**.

<details>
<summary>Collections.synchronizedMap의 문서화 예시</summary>

![image](https://github.com/TaemHam/effective-java-study/assets/95671168/733f9586-8146-4a75-831b-476f8d934efb)

반복문이나 스트림으로 내부 원소를 순회할 때 맵을 락으로 사용해 직접 동기화를 해야하며, <br>
이렇게 사용하지 않으면 동작을 예측할 수 없을 것이라고 경고하고 있다.

</details>

### 락

스레드 안정성을 위한 락을 사용하는 데에 두 가지 방법이 있다:

1. 외부에서 사용할 수 있는 **공개 락** 제공

  * 장점 <br>
    - 클라이언트에서 일련의 메서드 호출을 원자적으로 수행할 수 있다.

  * 단점 <br>
    - ConcurrentHashMap 같은 동시성 컬렉션이 제공하는 고성능 동시성 제어 메커니즘과 혼용할 수 없다.
    - 클라이언트가 공개된 락을 오래 쥐고 놓지 않는 서비스 거부 공격을 수행할 수도 있다.

2. 외부에서 동기화에 관여할 수 없도록 **비공개 락 객체**를 사용

  * 장점 <br>
    - 서비스 거부 공격을 막을 수 있다.
    - 상속용으로 설계한 클래스인 경우, 하위 클래스가 락을 조작해 해당 클래스의 동작을 방해하는 행위를 막을 수 있다.
  
  * 단점 <br>
    - 무조건적 스레드 안전 클래스에서만 사용할 수 있다. <br>
      조건부 스레드 안전 클래스에서는 호출 순서에 필요한 락이 무엇인지 알려줘야 해서 그렇다.