# 아이템 83. 지연 초기화는 신중히 사용하라

- 지연 초기화는 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다.

- 그래서 값이 전혀 쓰이지 않으면 초기화도 일어나지 않으며, 따라서 비용을 아낄 수 있다.

- 이 기법은 정적 필드, 인스턴스 필드에 모두 사용할 수 있다.

- 지연 초기화는 주로 최적화 용도로 쓰이지만, 클래스와 인스턴스 초기화 때 발생하는 순환 문제를 해결하는 효과도 있다.
  - 예를 들어 2개의 객체가 서로를 참조하고 있을 때, 한 쪽의 객체에 지연 초기화 기법을 사용함으로써 순환 참조가 발생하는 것을 막는 것이 있다.

<br>

## 지연 초기화는 언제 해야 할까?

- 다른 모든 최적화와 마찬가지로, 지연 초기화 또한 `필요할 때까지는 하지 않는 것`이 좋다.

- 지연 초기화를 사용하면 클래스나 인스턴스를 생성하는 시점의 초기화 비용은 줄지만, 필드에 접근하는 비용이 커진다.

  - getter 메서드에서 초기화를 하기 때문이다.

- 따라서 지연 초기화를 사용했을 때 더욱 성능이 느려질 수도 있다.

- 만약 특정 필드를 사용하는 비율이 낮고, 필드를 초기화 하는 비용이 크다면 지연 초기화를 쓰는 것이 나을 수 있다.

- 그러나 반드시 성능을 테스트하는 것이 좋다.

<br>

## 멀티 쓰레드 환경에서 지연 초기화 하기

- 지연 초기화하는 필드가 공유 자원이라면, 반드시 동기화를 해야 한다.

- 아래는 인스턴스 필드를 선언할 때 일반적 초기화와 지연 초기화를 비교한 것이다.

```java
// 일반적인 초기화 기법.
// 인스턴스가 생성될 때 final 필드로 초기화된다.
private final FieldType field = computFieldValue();

// 지연 초기화 기법.
// 필드에 접근할 때 필드를 초기화한다.
private FieldType field;

private synchronized FieldType getField() {
    if (field == null) {
        field = computFieldValue();
    }
    return field;
}

```

<br>

### 성능 때문에 정적 필드를 지연 초기화 하는 경우

- 성능 때문에 정적 필드를 지연 초기화해야 한다면, 지연 초기화 홀더 클래스 관용구를 사용하자.

- 클래스는 클래스가 처음 쓰일 때 초기화된다는 특성을 이용한 것이다.
  - 자바의 클래스는 처음 사용될 때 클래스 로더에 의해 메모리에 적재된다!

```java
private static class FieldHolder {
    static final FieldType field = computFieldValue();
}

private FieldType getField() {
    // 정적 필드가 호출 될 때 클래스 로더에 의해 메모리에 적재되며 초기화 된다.
    // 그리고 final 필드이므로 synchronized를 이용한 명시적인 동기화를 할 필요가 없다.
    return FieldHolder.field;
}

```

<br>

### 성능 때문에 인스턴스 필드를 지연 초기화 하는 경우

- 성능 때문에 인스턴스 필드를 지연 초기화해야 한다면, 이중검사 관용구를 사용하자.

- 이중검사 관용구란, 필드를 2번 검사하는 기법이다.

  - 필드가 초기화 되지 않았을 때는 동기화하여 검사한다.

  - 필드가 초기화 되었을 때는 동기화 없이 검사한다.

- final 필드가 아닌 경우에는, 필드가 초기화 된 이후로는 동기화를 하지 않으므로 반드시 volatile 키워드를 붙여 선언해야 한다.

  - volatile로 가시성 문제를 방지해야 한다.

```java
// 인스턴스 필드용 지연 초기화 이중검사 관용구
private volatile FieldType field;

private FieldType getField() {
    // 지역 변수를 사용하면 field를 읽을 때 1번만 읽게 해주는 효과가 있다.
    FieldType result = field;

    // 첫 번째 검사 (락 사용 안 함)
    if (result != null) {
        return result;
    }

    /*
    // 지역 변수를 사용하지 않았을 때는 field에 2번 접근해야 한다.
    if (field != null) {
        return field;
    }
    */

    // 두 번째 검사 (락 사용)
    synchronized(this) {
        if (field == null) {
            field = computeFieldValue();
        }
        return field;
    }
}
```

- 만약 반복해서 초기화 해야 하거나, 반복해서 초기화 해도 성능 이슈가 없는 경우는 다음과 같이 이중검사에서 두 번째 검사를 생략할 수 있다.

```java
// 인스턴스 필드용 지연 초기화 이중검사 관용구
private volatile FieldType field;

private FieldType getField() {
    FieldType result = field;

    if (result == null) {
        field = computeFieldValue();
    }
    return result;
}
```

- 모든 쓰레드가 필드의 값을 다시 계산해도 상관없고, 필드의 타입이 long과 double을 제외한 다른 기본 타입이라면 필드 선언에서 volatile을 생략해도 된다.

- 이는 단일검사 관용구라 불리는데, 보통 쓰이지는 않는다.

<br>

## 결론

- 지연 초기화는 `클래스나 인스턴스의 초기화 비용을 줄이는` 최적화 기법이다.

  - 최적화 기법이므로 `처음부터 사용하지 말고 필요할 때 사용하면`된다.

- 인스턴스 필드, 정적 필드에 따라 지연 초기화를 할 수 있는 기법이 다르다.

  - 인스턴스 필드의 경우에는 `이중 검사 관용구`를 사용할 수 있다.

  - 정적 필드의 경우에는 `지연 초기화 홀더 클래스 관용구`를 사용할 수 있다.

- 그러나 item81에 따라 동시성 유틸리티나, 동시성 자료구조를 사용할 수 있다면 그것을 사용하는 것이 좋을 것 같다.
